![](../images/괄호짝찾기.png)

## 🤞 Comment

### 사고 1

1. 출력 값을 보면 배열 단위로 반환이 됩니다.
2. 세 번째 테스트 케이스는 쌍을 이루고 있지 못해서 빈 배열([])이 반환됩니다.
3. 첫 번째 테스트 케이스 옳은 경우, 시작 값은 0부터 시작하기 때문에 시작 괄호와 끝 괄호를 배열 요소로 들어갑니다.
4. 문자열을 받아서 파싱합니다. <br>
   4-1. 쌍이 되는지 확인합니다. <br>
   4-2. 쌍이 되는 괄호의 시작 끝 위치를 찾아서 반환합니다. <br>

### 사고 2

1. 스택으로 풀 것입니다. 괄호는 스택으로 많이 풉니다.
2. 상반되는 경우 스택으로 풀 수 있습니다.<br>
   2-1. 두 번째 테스트 케이스는 시작 괄호와 마지막 괄호가 매핑됩니다.
   2-2. ( ( ) ) 를 stack에 넣습니다.<br>
   2-3. stack에 ( ( 를 넣고 ) 를 넣기 전 앞에 시작 괄호가 있기 때문에 두번 째 push한 ( 와 매핑하면 하나의 쌍이 됩니다. 이 쌍을 pop합니다.<br>
   2-4. 그럼 괄호() 한 쌍이 됐고 STACK에는 ( 하나만 남게 됩니다. <br>
   2-5. 남아 있는 )를 넣으면 또 한 쌍이 됩니다.

### 사고 3

1. 문자열 길이 만큼 for문 순회합니다.
2. str[i] === '(' 라면 stack에 push합니다. 결국 인덱스만 필요하니 인덱스만 push합니다.
3. str[i] === ')' 라면 '(' 있어야 한 쌍을 이룰 수 있는데, stack이 비어있다면 빈 배열을 반환합니다.
4. 3의 경우가 아니라면 stack에 있는 '(' 의 인덱스와 현재 시점의 ')' 의 인덱스를 배열로 result에 push합니다. 이 인덱스 쌍은 2차원 배열이됩니다.
5. 2~3 이 끝났는데 배열이 비어있지 않다면 완벽한 쌍이 되지 않은 괄호가 남아있는 것으로 빈 배열을 반환합니다.
